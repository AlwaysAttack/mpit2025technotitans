"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TravelMode = exports.Style = exports.Status = exports.SpeedAlertSeverity = exports.RoutingStrategy = exports.RouteStatus = exports.NightModeOptions = exports.NavigationInitErrorCode = exports.NavState = exports.DrivingSide = exports.DelaySeverity = exports.AudioGuidance = exports.AlternateRoutingStrategy = void 0;
/**
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Whether this step is on a drive-on-right or drive-on-left route. May be unspecified.
 */
let DrivingSide = exports.DrivingSide = /*#__PURE__*/function (DrivingSide) {
  /** Unspecified side. */
  DrivingSide[DrivingSide["NONE"] = 0] = "NONE";
  /** Drive-on-left side. */
  DrivingSide[DrivingSide["LEFT"] = 1] = "LEFT";
  /** Drive-on-right side. */
  DrivingSide[DrivingSide["RIGHT"] = 2] = "RIGHT";
  return DrivingSide;
}({});
/**
 * The state of navigation in Navigation SDK.
 */
let NavState = exports.NavState = /*#__PURE__*/function (NavState) {
  /** Error or unspecified state. */
  NavState[NavState["UNKNOWN"] = 0] = "UNKNOWN";
  /** Actively navigating. */
  NavState[NavState["ENROUTE"] = 1] = "ENROUTE";
  /** Actively navigating but searching for a new route. */
  NavState[NavState["REROUTING"] = 2] = "REROUTING";
  /** Navigation has ended. */
  NavState[NavState["STOPPED"] = 3] = "STOPPED";
  return NavState;
}({});
/**
 * Specify that the Navigation SDK should determine the appropriate day or night mode according to
 * user's location and local time.
 */
let NightModeOptions = exports.NightModeOptions = /*#__PURE__*/function (NightModeOptions) {
  /** Specify that the Navigation SDK should determine the appropriate day or night mode according to user's location and local time. */
  NightModeOptions[NightModeOptions["AUTO"] = 0] = "AUTO";
  /** Force day mode (default light map style). */
  NightModeOptions[NightModeOptions["FORCE_DAY"] = 1] = "FORCE_DAY";
  /** Force night mode (default dark map style). */
  NightModeOptions[NightModeOptions["FORCE_NIGHT"] = 2] = "FORCE_NIGHT";
  return NightModeOptions;
}({});
/**
 * Provides directions based on travel for a 4-wheeled, motorized vehicle. For example, a car or
 * two-wheeler, walking, taxi, cycling.
 */
let TravelMode = exports.TravelMode = /*#__PURE__*/function (TravelMode) {
  /** Provides directions based on travel for a 4-wheeled, motorized vehicle. */
  TravelMode[TravelMode["DRIVING"] = 0] = "DRIVING";
  /** Provides directions based on travel for a bicycle. */
  TravelMode[TravelMode["CYCLING"] = 1] = "CYCLING";
  /** Provides directions based on walking. */
  TravelMode[TravelMode["WALKING"] = 2] = "WALKING";
  /** Provides directions based on travel for 2-wheeled, motorized transport. */
  TravelMode[TravelMode["TWO_WHEELER"] = 3] = "TWO_WHEELER";
  /** Provides directions on routes for a vehicle authorized to use taxi lanes. */
  TravelMode[TravelMode["TAXI"] = 4] = "TAXI";
  return TravelMode;
}({});
/**
 * The routing strategy specifies how routes are ranked, which affects the route that is chosen
 * initially, and during re-routing. The default is {@link #DEFAULT_BEST}.
 */
let RoutingStrategy = exports.RoutingStrategy = /*#__PURE__*/function (RoutingStrategy) {
  /** Ranks routes by NavSDK's default cost model. This is the default routing strategy for navigating. */
  RoutingStrategy[RoutingStrategy["DEFAULT_BEST"] = 0] = "DEFAULT_BEST";
  /** Ranks routes by distance, shortest first. */
  RoutingStrategy[RoutingStrategy["SHORTER"] = 1] = "SHORTER";
  /** Ranks routes based on absolute delta to each distance provided by meters. */
  RoutingStrategy[RoutingStrategy["TARGET_DISTANCE"] = 2] = "TARGET_DISTANCE";
  return RoutingStrategy;
}({});
/**
 * Desired display strategy for showing alternate routes.
 */
let AlternateRoutingStrategy = exports.AlternateRoutingStrategy = /*#__PURE__*/function (AlternateRoutingStrategy) {
  /** Show all available alternate routes. */
  AlternateRoutingStrategy[AlternateRoutingStrategy["SHOW_ALL"] = 0] = "SHOW_ALL";
  /** Do not show alternate routes. */
  AlternateRoutingStrategy[AlternateRoutingStrategy["SHOW_NONE"] = 1] = "SHOW_NONE";
  /** Show at most one alternate route. */
  AlternateRoutingStrategy[AlternateRoutingStrategy["SHOW_ONE"] = 2] = "SHOW_ONE";
  return AlternateRoutingStrategy;
}({});
/**
 * A set of values used to specify the severity levels of speed alerts.
 */
let SpeedAlertSeverity = exports.SpeedAlertSeverity = /*#__PURE__*/function (SpeedAlertSeverity) {
  /**
   * Speed alert triggered when speeding above the speed limit by a major percentage, or speeding
   * for more than specified time, which are configured.
   */
  SpeedAlertSeverity[SpeedAlertSeverity["MAJOR"] = 0] = "MAJOR";
  /**
   * Speed alert triggered when speeding above the speed limit by a minor percentage that is
   * configured.
   */
  SpeedAlertSeverity[SpeedAlertSeverity["MINOR"] = 1] = "MINOR";
  /**
   * Speed alert not triggered, meaning one of the following conditions is satisfied:
   * - The speed is unknown.
   * - The speed limit is unknown.
   * - The driver is not speeding according to the thresholds configured.
   */
  SpeedAlertSeverity[SpeedAlertSeverity["NONE"] = 2] = "NONE";
  return SpeedAlertSeverity;
}({});
/**
 * The possible status values of the NavigationTrafficData.
 */
let Status = exports.Status = /*#__PURE__*/function (Status) {
  /** Traffic available */
  Status[Status["OK"] = 0] = "OK";
  /** Traffic information not available */
  Status[Status["UNAVAILABLE"] = 1] = "UNAVAILABLE";
  return Status;
}({});
/**
 * AudioGuidance is a set of flags used to specify what kinds of audio alerts and guidance are
 * used during navigation.
 */
let AudioGuidance = exports.AudioGuidance = /*#__PURE__*/function (AudioGuidance) {
  /**
   * Specifies that voice guidance should be transmitted over Bluetooth if available. This flag
   * must be combined with VOICE_ALERTS_ONLY or VOICE_ALERTS_AND_GUIDANCE to
   * have any effect.
   */
  AudioGuidance[AudioGuidance["BLUETOOTH_AUDIO"] = 8] = "BLUETOOTH_AUDIO";
  /**
   * Specifies that voice guidance and vibrations should be disabled. This flag should always be
   * specified by itself; it is a mistake to combine this with any other AudioGuidance
   * flags.
   */
  AudioGuidance[AudioGuidance["SILENT"] = 0] = "SILENT";
  /** Specifies that vibrations should be enabled. */
  AudioGuidance[AudioGuidance["VIBRATION"] = 1] = "VIBRATION";
  /**
   * Specifies that voice should be enabled for both alerts and turn-by-turn guidance
   * instructions. Note that this value alone will not allow voice guidance to be played over
   * Bluetooth; to enable that, BLUETOOTH_AUDIO should be added.
   */
  AudioGuidance[AudioGuidance["VOICE_ALERTS_AND_GUIDANCE"] = 4] = "VOICE_ALERTS_AND_GUIDANCE";
  /**
   * Specifies that voice should be enabled for alerts only (e.g., traffic incidents) but not for
   * turn-by-turn guidance instructions. Note that this value alone will not allow voice guidance
   * to be played over Bluetooth; to enable that, BLUETOOTH_AUDIO should be added.
   */
  AudioGuidance[AudioGuidance["VOICE_ALERTS_ONLY"] = 2] = "VOICE_ALERTS_ONLY";
  return AudioGuidance;
}({});
/**
 * Defines an individual road stretch within a route polyline, and its rendering style based on
 * traffic conditions. This is a NavSDK equivalent of the Google Maps RoadStretch.
 */
let Style = exports.Style = /*#__PURE__*/function (Style) {
  /** No style selected. */
  Style[Style["UNKNOWN"] = 0] = "UNKNOWN";
  /** Traffic is slowing down. */
  Style[Style["SLOWER_TRAFFIC"] = 1] = "SLOWER_TRAFFIC";
  /** There is a traffic jam. */
  Style[Style["TRAFFIC_JAM"] = 2] = "TRAFFIC_JAM";
  return Style;
}({});
/**
 * A RouteStatus is a status code that represents the result of a route calculation, accessed via
 * the returned of setDestinations.
 */
let RouteStatus = exports.RouteStatus = /*#__PURE__*/function (RouteStatus) {
  /** A route to the destination was successfully calculated. */
  RouteStatus[RouteStatus["OK"] = 0] = "OK";
  /** A route to the destination could not be calculated. */
  RouteStatus[RouteStatus["NO_ROUTE_FOUND"] = 1] = "NO_ROUTE_FOUND";
  /** A route to the destination could not be calculated because of a network error. */
  RouteStatus[RouteStatus["NETWORK_ERROR"] = 2] = "NETWORK_ERROR";
  /** A route to the destination could not be calculated because of insufficient quota. */
  RouteStatus[RouteStatus["QUOTA_CHECK_FAILED"] = 3] = "QUOTA_CHECK_FAILED";
  /** The route calculation was canceled in favor of a newer one. */
  RouteStatus[RouteStatus["ROUTE_CANCELED"] = 4] = "ROUTE_CANCELED";
  /** A route could not be calculated because the device location was not obtained in time. */
  RouteStatus[RouteStatus["LOCATION_DISABLED"] = 5] = "LOCATION_DISABLED";
  /** A route could not be calculated because the location could not be resolved in time. */
  RouteStatus[RouteStatus["LOCATION_UNKNOWN"] = 6] = "LOCATION_UNKNOWN";
  /**
   * The navigator could not calculate a route because the request contained an unrecognized
   * waypoint, or too many waypoints. For example, a waypoint may be unrecognized if it contains a
   * stale or invalid place ID.
   */
  RouteStatus[RouteStatus["WAYPOINT_ERROR"] = 7] = "WAYPOINT_ERROR";
  /** An invalid place it was used to define the route, check if that exists or if that has expired. */
  RouteStatus[RouteStatus["INVALID_PLACE_ID"] = 8] = "INVALID_PLACE_ID";
  /** The route could not be calculated because consecutive duplicate waypoints were provided. */
  RouteStatus[RouteStatus["DUPLICATE_WAYPOINTS_ERROR"] = 9] = "DUPLICATE_WAYPOINTS_ERROR";
  /** An unknown error has happened to generate the route. */
  RouteStatus[RouteStatus["UNKNOWN"] = 10] = "UNKNOWN";
  return RouteStatus;
}({});
/**
 * An ErrorCode is a status code returned by when trying to retrieve the Navigator
 * but that could not be successfully obtained.
 */
let NavigationInitErrorCode = exports.NavigationInitErrorCode = /*#__PURE__*/function (NavigationInitErrorCode) {
  /**
   * The API key you supplied is not authorized to use the Navigation API. You may need to request
   * provisioning of the Navigation SDK through your Google Maps APIs representative. Your app
   * should fall back to another navigation mechanism if this code is received.
   */
  NavigationInitErrorCode[NavigationInitErrorCode["NOT_AUTHORIZED"] = 1] = "NOT_AUTHORIZED";
  /** The user has not accepted Google's Navigation terms. */
  NavigationInitErrorCode[NavigationInitErrorCode["TERMS_NOT_ACCEPTED"] = 2] = "TERMS_NOT_ACCEPTED";
  /** The Navigation API is unable to access the internet. */
  NavigationInitErrorCode[NavigationInitErrorCode["NETWORK_ERROR"] = 3] = "NETWORK_ERROR";
  /** The app was not allowed to access the device's location or permission is yet to be granted. */
  NavigationInitErrorCode[NavigationInitErrorCode["LOCATION_PERMISSION_MISSING"] = 4] = "LOCATION_PERMISSION_MISSING";
  return NavigationInitErrorCode;
}({});
/**
 * Indicates how heavy traffic is.
 */
let DelaySeverity = exports.DelaySeverity = /*#__PURE__*/function (DelaySeverity) {
  /** No traffic data available. */
  DelaySeverity[DelaySeverity["NO_DATA"] = 0] = "NO_DATA";
  /** Heavy traffic in the route. */
  DelaySeverity[DelaySeverity["HEAVY"] = 1] = "HEAVY";
  /** Medium traffic in the route. */
  DelaySeverity[DelaySeverity["MEDIUM"] = 2] = "MEDIUM";
  /** Light traffic in the route. */
  DelaySeverity[DelaySeverity["LIGHT"] = 3] = "LIGHT";
  return DelaySeverity;
}({});
/**
 * Defines an individual road stretch within a route polyline, and its rendering style based on
 * traffic conditions. This is a NavSDK equivalent of the Google Maps RoadStretch.
 */
/**
 * Contains traffic data for a single "leg" of a journey (as represented by a RouteSegment)
 * relative to the current location of the vehicle.
 */
/**
 * Represents a single "leg" of a journey, either from
 * the device's current position to the destination, or from one destination to a subsequent
 * destination, along with NavigationTrafficData along the segment.
 */
/**
 * Used to specify navigation destinations. It may be constructed from
 * a latitude/longitude pair, or a Google Place ID.
 */
/**
 * Represents both time and distance to a destination.
 */
//# sourceMappingURL=types.js.map